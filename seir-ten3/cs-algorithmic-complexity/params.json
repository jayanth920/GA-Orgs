{
  "name": "Algorithmic Complexity",
  "tagline": "How algorithms perform in time",
  "body": "# Algorithmic Complexity & Big O Notation\r\n\r\n## Learning Objectives\r\n* Identify what makes a good algorithm\r\n* Use Big-O Analysis to Evaluate Algorithms\r\n\r\n### Framing (10 min / 9:10)\r\n\r\nLast week we learned what an algorithm is and why they are so important to the field of computer science.  This week we'll learn about how programmers measure the efficiency of algorithms and which types of algorithms are the most efficient in terms of *time* and *memory* consumption.  \r\n\r\nWho can remind me what the definition of an algorithm is?\r\n\r\nTo restate from last class, while we are still learning the fundamentals and are working with relatively *small inputs*, it is more important to have clean code, good interfaces, and bug-less applications. However, as our inputs grow in size, having efficient algorithms becomes extremely important!\r\n\r\nOur main concerns in terms of efficiency are *time* and *memory*. If our sites load slowly, users may leave. If our code takes up too much memory, it will be more expensive to host our sites.  \r\n\r\n## Run Time and Big-O Analysis (30 min / 9:40)\r\n\r\nWe can look at a program and say -- \"Oh that took two seconds to run\". But that two seconds is dependent on a lot of factors. That two seconds is for a very specific input - your computer on your network with a certain version of your programming language. Instead, we should generalize the algorithm's complexity.\r\n\r\nWe do so using a notation that mathematicians and computer scientists use, called Big-O notation. This notation standardizes how we discuss the efficiency of algorithms. ***Big-O really tells us how quickly the runtime grows as the input becomes arbitrarily large***.  Most of the time, we use Big-O notation to describe time complexity, but we can also use it to describe memory efficiency.\r\n\r\nBig-O notation is not an exact metric for benchmarking algorithms. Rather, it gives us an abstract idea about how costly or efficient an algorithm is, with respect to how much computing power it takes. With Big-O notation, we are comparing orders of magnitude.\r\n\r\nA few notes on Big-O notation:\r\n* When we calculate the Big-O of the function, we are calculating the **worst** possible runtime for a given function.\r\n* Sometimes, Big-O notation is referred to as [asymptotic analysis](http://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec19-asymp/review.html).\r\n\r\nFor time complexity, we want to count how many times the code is run in context of how large the input to the code is. For example, O(1) is a very efficient piece of code, O(N!) is very inefficient. Let's break this down into categories of Big-O.\r\n\r\n### O(1) Complexity (aka Constant Complexity)\r\n\r\nO(1) means that an algorithm's runtime is static or constant. *The complexity stays the same no matter the input*.\r\n\r\n```javascript\r\nfunction helloWorld (arr) {\r\n\tconsole.log('hello world')\r\n}\r\n\r\nfunction returnFirstItem (arr) {\r\n\treturn arr[0]\r\n}\r\n```\r\n\r\nIn both of the above examples, no matter what size the `arr` argument is, the function will run once.\r\n\r\n### O(N) Complexity (aka Linear Complexity)\r\n\r\nO(N) complexity means that, as the input sizes increase, the processing time increases linearly. Or, more simply, *the code runs once for each input*.\r\n\r\n```javascript\r\nfunction iterate (arr) {\r\n\tarr.forEach(item => console.log(item))\r\n}\r\n\r\nfunction iterateLoop (arr) {\r\n\tfor (let i = 0; i < arr.length; i++) {\r\n\t\tconsole.log(arr[i])\r\n\t}\r\n}\r\n\r\nfunction addOne (arr) {\r\n\treturn arr.map(item => item + 1)\r\n}\r\n```\r\n\r\nIn each of the above examples, we go through the array and perform an action with each item in it. If we have the array `[1]`, each will execute once. If we have the array `[3, 5, 1000]` the code will run 3 times. If our array has 1000 items, the code will execute 1000 times!\r\n\r\n### O(N^2) Complexity (aka Quadratic Complexity)\r\n\r\nFor an input with the size n, *quadratically complex algorithms execute `n*n` times*.\r\n\r\n```javascript\r\nfunction consoleLogLots (arr) {\r\n\tfor (let i = 0; i < arr.length; i++) {\r\n\t\tfor (let j = 0; j < arr.length; j++) {\r\n\t\t\tconsole.log(arr[i], arr[j])\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nFor the array `[1, 3]`, this function will print:\r\n```js\r\n[1, 1]\r\n[1, 3]\r\n[3, 1]\r\n[3, 3]\r\n```\r\nFor a 2 item array, the code executes 4 times. For 3 items, the code executes 9 times.  This scales pretty fast -- for an array with 100 items this code will `console.log` 10,000 times!\r\n\r\n### O(log n) and O(n log n) Complexity\r\n\r\nO(log n) refers to algorithms which cut the problem in half each time. These have significantly lower complexity than O(n). We don't actually have to calculate logarithms or anything like that! Technically, a logarithm is a \"quantity representing the power to which a fixed number (the base) must be raised to produce a given number.\" [source](https://en.wikipedia.org/wiki/Logarithm)\r\n>Examples...\r\n\r\n- the base 10 logarithm of 1000 is 3 since 10^3 is 1000.\r\n- log<sub>2</sub> 32 = 5\r\n\r\nOne example of an O(log n) algorithm is a **binary search**. In an *unsorted* array, if we want to find the index of an item with a given value, we have to iterate through it and check if each item is equal to the item we are searching for. However, if we know that we have a **sorted** array, we can do this a lot easier!\r\n\r\nFor the array `[1, 3, 5, 7, 9, 11, 13]`, if we want to find the index of the 5, we can do so like this:\r\n* Find the item at the midpoint of the array. This ends up being `7`.\r\n* Our item is below 7, so then, since our array is sorted, we only have to search the half of the array before the 7.\r\n* The midpoint of the sub array from 1-7 or `[1, 3, 5]` is `3`.\r\n* This time, 5 is larger than 3, so we search the sub-array `[5]`. Since the midpoint of that array `5` is equal to the number we are searching for, we just return that number.\r\n\r\nLet's checkout a ***[visualization](https://www.cs.usfca.edu/~galles/visualization/Search.html)***\r\n\r\nAn implementation of that algorithm is below:\r\n```javascript\r\nfunction binarySearch(arr, item, first = 0, last = null) {\r\n\tif (!last) last = arr.length - 1\r\n  \r\n\tlet midpoint = Math.floor((last - first) / 2) + first\r\n\r\n\tif (arr[midpoint] === item) return midpoint\r\n\tif (arr[midpoint] > item) return binarySearch(arr, item, first, midpoint)\r\n\tif (arr[midpoint] < item) return binarySearch(arr, item, midpoint, last)\r\n}\r\n```\r\n\r\nThe above function ran 3 times instead of the 7 that we would need if we iterated through the entire array! This algorithm is super efficient -- even if we have a million items in our array, on average we will only need to execute the binary search 20 times.\r\n\r\nO(n log n) algorithms are ones that are faster than O(n^2) but slower than O(n). Let's come back to O(n log n) in a minute -- a lot of sorting algorithms fall under this category.\r\n\r\n### O(n!) and O(2^n)\r\n\r\nO(n!) and O(2^n) complexities should make you very nervous! These should be avoided at all costs. One example of an O(n!) algorithm is the Bogosort - aka the slowsort. This sort is when an array is randomly ordered over and over again until it is in the correctly sorted order. For an array with the length 10, this sort may have to run up to 3,628,800 times! Sometimes you will have to look at all the available combinations and writing code that are in these complexity categories can't be avoided, but they should bring up some red flags!\r\n\r\n### Drop the Coefficients, Constants, and less Significant Terms\r\n\r\nWith Big-O analysis, it is convention to drop the coefficients and constants. This helps us generalize our how efficient our algorithms will be.  \r\n\r\nFor example:\r\n```javascript\r\nfunction iter (arr) {\r\n\t// Big-O: N\r\n\tarr.forEach(item => console.log(item))\r\n\tarr.forEach(item => console.log(item))\r\n\tconsole.log('hello world')\r\n}\r\n\r\nfunction helloWorld () {\r\n\t// Big-O: 1\r\n\tconsole.log('hello world')\r\n\tconsole.log('hello world')\r\n}\r\n```\r\nThe above examples, at first look would have complexities of O(2N + 1) and O(2) respectively; however, in order to keep things simple, we can drop the coefficients. The time complexities are still linear and constant respectively. We take the least efficient operation within the block of code to measure its efficiency.\r\n\r\nHere are some more examples where you want to drop the less significant terms...\r\n\r\n<code>O(n​<sup>3</sup> ​​+ 50n<sup>​2</sup>​​ + 10000) = O(n​<sup>3</sup>​​)</code>\r\n\r\n<code>O(n+30) x O(n+5) = O(n​<sup>2</sup>​​)</code>\r\n\r\nThe most significant term always wins out in the end!\r\n\r\n### Big-O Summary\r\n![](https://i.stack.imgur.com/jIGhf.png)\r\n\r\nThe following table shows how algorithms with different complexities scale when given different numbers of inputs. Note: some values are rounded.\r\n\r\n|Complexity |1|10      |100  |\r\n|-----------|-|--------|-----|\r\n|O(1)       |1| 1      |1    |\r\n|O(log N)   |0| 2      |5    |\r\n|O(N)       |1|10      |100                            |\r\n|O(N log N) |0|20      |461                            |\r\n|O(N^2)     |1|100     |10000                          |\r\n|O(2^N)     |1|1024    |1267650600228229401496703205376|       \r\n|O(N!)      |1|3628800 |doesn't fit on screen! |\r\n\r\n\r\nLet's look at this demo in javascript...\r\n- Code: [JS](https://git.generalassemb.ly/ga-wdi-lessons/cs-algorithms/blob/master/js-example/script.js), [HTML](https://git.generalassemb.ly/ga-wdi-lessons/cs-algorithms/blob/master/js-example/index.html)\r\n- [Deployed](http://aboard-thought.surge.sh)\r\n\r\n### You Do: Study Big-O Families (10 min / 9:50)\r\n\r\n[Write down the complexities of these functions](https://gist.github.com/amaseda/c4283f5c58b9b68be9318259098f0298).\r\n\r\n\r\n## Learn More!\r\n* https://www.youtube.com/watch?v=V6mKVRU1evU\r\n* http://www.cs.cmu.edu/afs/cs/academic/class/15451-s10/www/lectures/lect0203.pdf\r\n* https://stackoverflow.com/questions/487258/what-is-a-plain-english-explanation-of-big-o-notation/487278\r\n* https://www.codenewbie.org/basecs\r\n* http://bigocheatsheet.com/\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}