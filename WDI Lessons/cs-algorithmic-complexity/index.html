<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Algorithmic Complexity by ga-wdi-lessons</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Algorithmic Complexity</h1>
        <p>How algorithms perform in time</p>

        <p class="view"><a href="https://git.generalassemb.ly/ga-wdi-lessons/cs-algorithmic-complexity">View the Project on GitHub <small>ga-wdi-lessons/cs-algorithmic-complexity</small></a></p>


      </header>
      <section>
        <h1>
<a id="algorithmic-complexity--big-o-notation" class="anchor" href="#algorithmic-complexity--big-o-notation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Algorithmic Complexity &amp; Big O Notation</h1>
<h2>
<a id="learning-objectives" class="anchor" href="#learning-objectives" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Learning Objectives</h2>
<ul>
<li>Identify what makes a good algorithm</li>
<li>Use Big-O Analysis to Evaluate Algorithms</li>
</ul>
<h3>
<a id="framing-10-min--910" class="anchor" href="#framing-10-min--910" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Framing (10 min / 9:10)</h3>
<p>Last week we learned what an algorithm is and why they are so important to the field of computer science.  This week we'll learn about how programmers measure the efficiency of algorithms and which types of algorithms are the most efficient in terms of <em>time</em> and <em>memory</em> consumption.</p>
<p>Who can remind me what the definition of an algorithm is?</p>
<p>To restate from last class, while we are still learning the fundamentals and are working with relatively <em>small inputs</em>, it is more important to have clean code, good interfaces, and bug-less applications. However, as our inputs grow in size, having efficient algorithms becomes extremely important!</p>
<p>Our main concerns in terms of efficiency are <em>time</em> and <em>memory</em>. If our sites load slowly, users may leave. If our code takes up too much memory, it will be more expensive to host our sites.</p>
<h2>
<a id="run-time-and-big-o-analysis-30-min--940" class="anchor" href="#run-time-and-big-o-analysis-30-min--940" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Run Time and Big-O Analysis (30 min / 9:40)</h2>
<p>We can look at a program and say -- "Oh that took two seconds to run". But that two seconds is dependent on a lot of factors. That two seconds is for a very specific input - your computer on your network with a certain version of your programming language. Instead, we should generalize the algorithm's complexity.</p>
<p>We do so using a notation that mathematicians and computer scientists use, called Big-O notation. This notation standardizes how we discuss the efficiency of algorithms. <em><strong>Big-O really tells us how quickly the runtime grows as the input becomes arbitrarily large</strong></em>.  Most of the time, we use Big-O notation to describe time complexity, but we can also use it to describe memory efficiency.</p>
<p>Big-O notation is not an exact metric for benchmarking algorithms. Rather, it gives us an abstract idea about how costly or efficient an algorithm is, with respect to how much computing power it takes. With Big-O notation, we are comparing orders of magnitude.</p>
<p>A few notes on Big-O notation:</p>
<ul>
<li>When we calculate the Big-O of the function, we are calculating the <strong>worst</strong> possible runtime for a given function.</li>
<li>Sometimes, Big-O notation is referred to as <a href="http://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec19-asymp/review.html">asymptotic analysis</a>.</li>
</ul>
<p>For time complexity, we want to count how many times the code is run in context of how large the input to the code is. For example, O(1) is a very efficient piece of code, O(N!) is very inefficient. Let's break this down into categories of Big-O.</p>
<h3>
<a id="o1-complexity-aka-constant-complexity" class="anchor" href="#o1-complexity-aka-constant-complexity" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>O(1) Complexity (aka Constant Complexity)</h3>
<p>O(1) means that an algorithm's runtime is static or constant. <em>The complexity stays the same no matter the input</em>.</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">helloWorld</span> (<span class="pl-smi">arr</span>) {
	<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>hello world<span class="pl-pds">'</span></span>)
}

<span class="pl-k">function</span> <span class="pl-en">returnFirstItem</span> (<span class="pl-smi">arr</span>) {
	<span class="pl-k">return</span> arr[<span class="pl-c1">0</span>]
}</pre></div>
<p>In both of the above examples, no matter what size the <code>arr</code> argument is, the function will run once.</p>
<h3>
<a id="on-complexity-aka-linear-complexity" class="anchor" href="#on-complexity-aka-linear-complexity" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>O(N) Complexity (aka Linear Complexity)</h3>
<p>O(N) complexity means that, as the input sizes increase, the processing time increases linearly. Or, more simply, <em>the code runs once for each input</em>.</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">iterate</span> (<span class="pl-smi">arr</span>) {
	<span class="pl-smi">arr</span>.<span class="pl-c1">forEach</span>(<span class="pl-smi">item</span> <span class="pl-k">=&gt;</span> <span class="pl-en">console</span>.<span class="pl-c1">log</span>(item))
}

<span class="pl-k">function</span> <span class="pl-en">iterateLoop</span> (<span class="pl-smi">arr</span>) {
	<span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">arr</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
		<span class="pl-en">console</span>.<span class="pl-c1">log</span>(arr[i])
	}
}

<span class="pl-k">function</span> <span class="pl-en">addOne</span> (<span class="pl-smi">arr</span>) {
	<span class="pl-k">return</span> <span class="pl-smi">arr</span>.<span class="pl-en">map</span>(<span class="pl-smi">item</span> <span class="pl-k">=&gt;</span> item <span class="pl-k">+</span> <span class="pl-c1">1</span>)
}</pre></div>
<p>In each of the above examples, we go through the array and perform an action with each item in it. If we have the array <code>[1]</code>, each will execute once. If we have the array <code>[3, 5, 1000]</code> the code will run 3 times. If our array has 1000 items, the code will execute 1000 times!</p>
<h3>
<a id="on2-complexity-aka-quadratic-complexity" class="anchor" href="#on2-complexity-aka-quadratic-complexity" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>O(N^2) Complexity (aka Quadratic Complexity)</h3>
<p>For an input with the size n, <em>quadratically complex algorithms execute <code>n*n</code> times</em>.</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">consoleLogLots</span> (<span class="pl-smi">arr</span>) {
	<span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">arr</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
		<span class="pl-k">for</span> (<span class="pl-k">let</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> <span class="pl-smi">arr</span>.<span class="pl-c1">length</span>; j<span class="pl-k">++</span>) {
			<span class="pl-en">console</span>.<span class="pl-c1">log</span>(arr[i], arr[j])
		}
	}
}</pre></div>
<p>For the array <code>[1, 3]</code>, this function will print:</p>
<div class="highlight highlight-source-js"><pre>[<span class="pl-c1">1</span>, <span class="pl-c1">1</span>]
[<span class="pl-c1">1</span>, <span class="pl-c1">3</span>]
[<span class="pl-c1">3</span>, <span class="pl-c1">1</span>]
[<span class="pl-c1">3</span>, <span class="pl-c1">3</span>]</pre></div>
<p>For a 2 item array, the code executes 4 times. For 3 items, the code executes 9 times.  This scales pretty fast -- for an array with 100 items this code will <code>console.log</code> 10,000 times!</p>
<h3>
<a id="olog-n-and-on-log-n-complexity" class="anchor" href="#olog-n-and-on-log-n-complexity" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>O(log n) and O(n log n) Complexity</h3>
<p>O(log n) refers to algorithms which cut the problem in half each time. These have significantly lower complexity than O(n). We don't actually have to calculate logarithms or anything like that! Technically, a logarithm is a "quantity representing the power to which a fixed number (the base) must be raised to produce a given number." <a href="https://en.wikipedia.org/wiki/Logarithm">source</a></p>
<blockquote>
<p>Examples...</p>
</blockquote>
<ul>
<li>the base 10 logarithm of 1000 is 3 since 10^3 is 1000.</li>
<li>log<sub>2</sub> 32 = 5</li>
</ul>
<p>One example of an O(log n) algorithm is a <strong>binary search</strong>. In an <em>unsorted</em> array, if we want to find the index of an item with a given value, we have to iterate through it and check if each item is equal to the item we are searching for. However, if we know that we have a <strong>sorted</strong> array, we can do this a lot easier!</p>
<p>For the array <code>[1, 3, 5, 7, 9, 11, 13]</code>, if we want to find the index of the 5, we can do so like this:</p>
<ul>
<li>Find the item at the midpoint of the array. This ends up being <code>7</code>.</li>
<li>Our item is below 7, so then, since our array is sorted, we only have to search the half of the array before the 7.</li>
<li>The midpoint of the sub array from 1-7 or <code>[1, 3, 5]</code> is <code>3</code>.</li>
<li>This time, 5 is larger than 3, so we search the sub-array <code>[5]</code>. Since the midpoint of that array <code>5</code> is equal to the number we are searching for, we just return that number.</li>
</ul>
<p>Let's checkout a <em><strong><a href="https://www.cs.usfca.edu/%7Egalles/visualization/Search.html">visualization</a></strong></em></p>
<p>An implementation of that algorithm is below:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">binarySearch</span>(<span class="pl-smi">arr</span>, <span class="pl-smi">item</span>, <span class="pl-smi">first</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>, <span class="pl-smi">last</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>) {
	<span class="pl-k">if</span> (<span class="pl-k">!</span>last) last <span class="pl-k">=</span> <span class="pl-smi">arr</span>.<span class="pl-c1">length</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>
  
	<span class="pl-k">let</span> midpoint <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>((last <span class="pl-k">-</span> first) <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> first

	<span class="pl-k">if</span> (arr[midpoint] <span class="pl-k">===</span> item) <span class="pl-k">return</span> midpoint
	<span class="pl-k">if</span> (arr[midpoint] <span class="pl-k">&gt;</span> item) <span class="pl-k">return</span> <span class="pl-en">binarySearch</span>(arr, item, first, midpoint)
	<span class="pl-k">if</span> (arr[midpoint] <span class="pl-k">&lt;</span> item) <span class="pl-k">return</span> <span class="pl-en">binarySearch</span>(arr, item, midpoint, last)
}</pre></div>
<p>The above function ran 3 times instead of the 7 that we would need if we iterated through the entire array! This algorithm is super efficient -- even if we have a million items in our array, on average we will only need to execute the binary search 20 times.</p>
<p>O(n log n) algorithms are ones that are faster than O(n^2) but slower than O(n). Let's come back to O(n log n) in a minute -- a lot of sorting algorithms fall under this category.</p>
<h3>
<a id="on-and-o2n" class="anchor" href="#on-and-o2n" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>O(n!) and O(2^n)</h3>
<p>O(n!) and O(2^n) complexities should make you very nervous! These should be avoided at all costs. One example of an O(n!) algorithm is the Bogosort - aka the slowsort. This sort is when an array is randomly ordered over and over again until it is in the correctly sorted order. For an array with the length 10, this sort may have to run up to 3,628,800 times! Sometimes you will have to look at all the available combinations and writing code that are in these complexity categories can't be avoided, but they should bring up some red flags!</p>
<h3>
<a id="drop-the-coefficients-constants-and-less-significant-terms" class="anchor" href="#drop-the-coefficients-constants-and-less-significant-terms" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Drop the Coefficients, Constants, and less Significant Terms</h3>
<p>With Big-O analysis, it is convention to drop the coefficients and constants. This helps us generalize our how efficient our algorithms will be.</p>
<p>For example:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">iter</span> (<span class="pl-smi">arr</span>) {
	<span class="pl-c"><span class="pl-c">//</span> Big-O: N</span>
	<span class="pl-smi">arr</span>.<span class="pl-c1">forEach</span>(<span class="pl-smi">item</span> <span class="pl-k">=&gt;</span> <span class="pl-en">console</span>.<span class="pl-c1">log</span>(item))
	<span class="pl-smi">arr</span>.<span class="pl-c1">forEach</span>(<span class="pl-smi">item</span> <span class="pl-k">=&gt;</span> <span class="pl-en">console</span>.<span class="pl-c1">log</span>(item))
	<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>hello world<span class="pl-pds">'</span></span>)
}

<span class="pl-k">function</span> <span class="pl-en">helloWorld</span> () {
	<span class="pl-c"><span class="pl-c">//</span> Big-O: 1</span>
	<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>hello world<span class="pl-pds">'</span></span>)
	<span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>hello world<span class="pl-pds">'</span></span>)
}</pre></div>
<p>The above examples, at first look would have complexities of O(2N + 1) and O(2) respectively; however, in order to keep things simple, we can drop the coefficients. The time complexities are still linear and constant respectively. We take the least efficient operation within the block of code to measure its efficiency.</p>
<p>Here are some more examples where you want to drop the less significant terms...</p>
<p><code>O(n​<sup>3</sup> ​​+ 50n<sup>​2</sup>​​ + 10000) = O(n​<sup>3</sup>​​)</code></p>
<p><code>O(n+30) x O(n+5) = O(n​<sup>2</sup>​​)</code></p>
<p>The most significant term always wins out in the end!</p>
<h3>
<a id="big-o-summary" class="anchor" href="#big-o-summary" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Big-O Summary</h3>
<p><img src="https://i.stack.imgur.com/jIGhf.png" alt=""></p>
<p>The following table shows how algorithms with different complexities scale when given different numbers of inputs. Note: some values are rounded.</p>
<table>
<thead>
<tr>
<th>Complexity</th>
<th>1</th>
<th>10</th>
<th>100</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(1)</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>O(log N)</td>
<td>0</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>O(N)</td>
<td>1</td>
<td>10</td>
<td>100</td>
</tr>
<tr>
<td>O(N log N)</td>
<td>0</td>
<td>20</td>
<td>461</td>
</tr>
<tr>
<td>O(N^2)</td>
<td>1</td>
<td>100</td>
<td>10000</td>
</tr>
<tr>
<td>O(2^N)</td>
<td>1</td>
<td>1024</td>
<td>1267650600228229401496703205376</td>
</tr>
<tr>
<td>O(N!)</td>
<td>1</td>
<td>3628800</td>
<td>doesn't fit on screen!</td>
</tr>
</tbody>
</table>
<p>Let's look at this demo in javascript...</p>
<ul>
<li>Code: <a href="https://git.generalassemb.ly/ga-wdi-lessons/cs-algorithms/blob/master/js-example/script.js">JS</a>, <a href="https://git.generalassemb.ly/ga-wdi-lessons/cs-algorithms/blob/master/js-example/index.html">HTML</a>
</li>
<li><a href="http://aboard-thought.surge.sh">Deployed</a></li>
</ul>
<h3>
<a id="you-do-study-big-o-families-10-min--950" class="anchor" href="#you-do-study-big-o-families-10-min--950" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>You Do: Study Big-O Families (10 min / 9:50)</h3>
<p><a href="https://gist.github.com/amaseda/c4283f5c58b9b68be9318259098f0298">Write down the complexities of these functions</a>.</p>
<h2>
<a id="learn-more" class="anchor" href="#learn-more" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Learn More!</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=V6mKVRU1evU">https://www.youtube.com/watch?v=V6mKVRU1evU</a></li>
<li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15451-s10/www/lectures/lect0203.pdf">http://www.cs.cmu.edu/afs/cs/academic/class/15451-s10/www/lectures/lect0203.pdf</a></li>
<li><a href="https://stackoverflow.com/questions/487258/what-is-a-plain-english-explanation-of-big-o-notation/487278">https://stackoverflow.com/questions/487258/what-is-a-plain-english-explanation-of-big-o-notation/487278</a></li>
<li><a href="https://www.codenewbie.org/basecs">https://www.codenewbie.org/basecs</a></li>
<li><a href="http://bigocheatsheet.com/">http://bigocheatsheet.com/</a></li>
</ul>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://git.generalassemb.ly/ga-wdi-lessons">ga-wdi-lessons</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
