## Data (Im)mutability in Ruby

### Learning Objectives

* Demonstrate how variables are stored in and removed from memory using Ruby.
* Use `!` to modify values in memory.
* Identify the use cases for Symbols in Ruby.

### Framing (5 minutes / 0:05)

In Javascript, we don't have to worry about our actions having unintended consequences in memory. Take the following example...

```js
var a = "hello world";

var b = a;
// Here we might expect that `pointToThatString` will point to the same location in memory that `aString` is pointing too.

a;
// => "hello world"

b;
// => "hello world"
```

So both variables print the same value to the console.
* What happens if we modify the value that is stored in `a`. Will that then change what is stored in `b`?

```js
a = a.toUpperCase();
a;
// => "HELLO WORLD"

b;
// => ???
```

If we ran the Ruby equivalent of this code, it would actually have the same result. But there are other similar scenarios in Ruby in which memory allocation may have unintended consequences. We'll also learn about immutable data types such as Symbols that are not subject to changes.

### Variables and Mutability (15 minutes / 0:20)

Let's talk about variables and memory allocation in Ruby.

Haha!

![XKCD pointers comic](https://camo.githubusercontent.com/e015a8e243f53ffecd9b18fc5c8d770dde1948cc/687474703a2f2f626c6f672e70726f7465637465647374617469632e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030372f30352f706f696e746572732e706e67)

Why is that so funny? Because variables are pointers to values in memory.

![Variables in memory diagram](https://camo.githubusercontent.com/62b04af497f124fc9b11ec3802d73497f5c9e305/687474703a2f2f64326177357865326a6c647175652e636c6f756466726f6e742e6e65742f626f6f6b732f727562792f696d616765732f7661726961626c65735f706f696e74657273312e6a7067)

<a href="https://imgflip.com/gif/t9736"><img src="https://i.imgflip.com/t9736.gif" title="made at imgflip.com"/></a>

#### Retrieving Memory Location

We can use the `.object_id` method to demonstrate that two variables are pointing to the same object.
* Returns an integer identifier for the object that is automatically generated by Ruby.
* Lets use `.object_id` to demonstrate that the first diagram in this lesson is true.

```rb
a = "hi there"
# => "hi there"

b = a
# => "hi there"

a.object_id
# => 70096095324100

b.object_id
# => 70096095324100

a = "not here"
# => "not here"

a.object_id
# => 70096094155620

b.object_id
# => 70096095324100
```

#### The Bang Symbol (`!`)

All of the Ruby data types we have discussed so far -- with the exception of symbols and numbers -- are mutable.
* We can not only change what variables are pointing to in memory, but we can directly modify those values stored in memory as well.

Methods with an `!` attached to the end of them usually mean that they will modify the value in memory they are being called on.
* Things can get tricky when you have multiple variables pointing at the same value. For example...

```rb
a = "cheeseburger"
# => "cheeseburger"

b = a
# => "cheeseburger"

b.upcase!
# => "CHEESEBURGER"

a
# => "CHEESEBURGER"
```

#### Garbage Collection

What happens to a value in memory when it is no longer being pointed at by a variable?

```rb
a = "cheeseburger"
b = a

a # => "cheeseburger"
b # => "cheeseburger"

a = "hot dog"
b # => "cheeseburger"

b = "nachos"
b # => "nachos"
```

What happened to the memory location that stored `"cheeseburger"` at the start of the above code snippet? **Garbage Collection.**
* Because nothing is pointing to that memory location, Ruby clears it up for later use.

#### Reassignment...  
<a href="https://imgflip.com/gif/t984f"><img src="https://i.imgflip.com/t984f.gif" title="made at imgflip.com"/></a>

#### ...vs Replacement
<a href="https://imgflip.com/gif/t98b3"><img src="https://i.imgflip.com/t98b3.gif" title="made at imgflip.com"/></a>

### Exercise: Variable Assignment (15 minutes / 0:35)

[Exercise: Variable Assignment](https://gist.github.com/amaseda/35a62128d8795e045d49)
* Work in pairs and answer the questions in the link above.
* **NO CODING ALLOWED!** Stretch those brain muscles and talk these out with your partner.
* Writing these out on your table/whiteboard with markers is strongly encouraged.

### Symbols and (Im)mutability (10 minutes / 0:45)

Symbols are immutable values. That means they contain the same value through the entirety of a program and cannot be changed.
* Kind of like a string that never changes.
* Syntax: `variable_name = :symbol_name`
* No Javascript equivalent (that is, [until ES6 came along](https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/)).

```rb
favorite_animal = :dog
# => :dog

other_favorite_animal = :killer_whale
# => :killer_whale

another_favorite_animal = :"flying squirrel"
# => :"flying squirrel"
```

You can convert symbols to -- but not replace them with -- other data types.

```rb
favorite_animal = :dog
# => :dog

favorite_animal.to_s
# => "dog"

favorite_animal = :dog
# => :dog
# Calling `.to_s` on `favorite_animal` does not convert the original value. It's still a symbol.
```

#### When/Why Would You Use Symbols?

##### Enhance Performance. Use Less Memory.  
Not only can symbols not be changed, but each symbol occupies one place in memory no matter how many times it is used.  

```rb
george_washington = :president
# => :president

barack_obama = :president
# => :president

george_washington.object_id
# => 3202868

barack_obama.object_id
# => 3202868
```

##### Representing Concepts.

Say we have a variable `light_switch`. We know that it will only have two values: `on` or `off`.
* As such, we know it will never be anything other than `on` or `off`. We also know that we will never need to modify the values `on` or `off`.
* We could use strings to indicate the status of `light_switch`. But in doing so, we are creating a new value in memory every a light switch is "flicked".

```rb
light_switch = "on"
light_switch.object_id
# => 70217024652700

light_switch = "off"
light_switch.object_id
# => 70217024477120

light_switch = "on"
light_switch.object_id
# => 70217028084580
```
> Note that when `light_switch` is set to `on` for a second time, `"on"` occupies a different place in memory than the first time.

Now this example may not be the best since garbage collection ends up freeing the spaces in memory that are no longer being used.
* But imagine if we were dealing with a light switch for every room in a mansion. That would be a lot of memory locations being used for only two values: `on` and `off`.
* Symbols would allow us to represent `on` and `off`, regardless of how many light switches there are, using only two memory locations.

```rb
light_switch_hallway = :on
light_switch_kitchen = :on
light_switch_bathroom = :on

light_switch_hallway.object_id
# => 2053788

light_switch_kitchen.object_id
# => 2053788

light_switch_bathroom.object_id
# => 2053788
```
> Note that all three variables reference the same location in memory.

This is important because we are trying to represent the **concepts** of `on` and `off`, not the strings. Symbols are a useful way of doing this.

A more practical example: imagine that you have built a web application and you allow the user to sign in using one of a three services: `Facebook` `Twitter` and `Instagram`.
* You indicate this using a `service` instance variable in a `User` class.
* **Q:** How could symbols be useful here?

##### Symbols as Hash Keys.  

* Imagine you're creating hashes to represent every instructor that works for GA. They would something like this...  

```rb
jesse = {
  name: "Jesse Shawl",
  location: "DC",
  cohort: "WDI8"
}

jeff = {
  name: "Jeff Horn",
  location: "Boston",
  cohort: "WDI5"
}
```

We know the keys for each of these hashes will be the exact same. So rather than instantiate these keys as strings and devote a location in memory to each of them -- which could end up totaling in the hundreds! -- why not just use symbols?  
* If each instructor has the same three keys, we only need three memory locations to store them.

### Closing / Questions (5 minutes / 0:50)

### Further Reading

* [Freezing String Literals and Constants in Ruby](http://josephyi.com/freeze/)
* [Unraveling String Key Performance in Ruby](http://www.sitepoint.com/unraveling-string-key-performance-ruby-2-2/)
* [From Ruby Immutability to Functional Programming](http://valve.github.io/blog/2014/07/04/from-object-to-functional-immutability/)
